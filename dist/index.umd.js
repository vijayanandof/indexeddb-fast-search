!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).FastIndexedDB={})}(this,(function(e){"use strict";class t{constructor(e,t){this.options={},this.db=e,this.storeName=t}where(e){return this.indexName=e,this}equals(e){return this.query=e,this}above(e){return this.query=IDBKeyRange.lowerBound(e,!0),this}aboveOrEqual(e){return this.query=IDBKeyRange.lowerBound(e),this}below(e){return this.query=IDBKeyRange.upperBound(e,!0),this}belowOrEqual(e){return this.query=IDBKeyRange.upperBound(e),this}between(e,t,r=!0,s=!0){return this.query=IDBKeyRange.bound(e,t,!r,!s),this}limit(e){return this.options.limit=e,this}offset(e){return this.options.offset=e,this}reverse(){return this.options.direction="prev",this}async toArray(){return this.indexName?this.db.findByIndexRange(this.storeName,this.indexName,{query:this.query,...this.options}):this.db.getAll(this.storeName)}async count(){return this.indexName&&this.query?this.db.countByIndex(this.storeName,this.indexName,this.query):this.db.count(this.storeName)}async first(){return(await this.limit(1).toArray())[0]}async last(){return(await this.reverse().limit(1).toArray())[0]}}e.FastIndexedDB=class{constructor(e,t,r){this.db=null,this.dbName=e,this.version=t,this.schema=r}async getStore(e,t="readonly"){this.db||await this.open();return this.db.transaction(e,t).objectStore(e)}async open(){return new Promise(((e,t)=>{const r=indexedDB.open(this.dbName,this.version);r.onerror=()=>t(r.error),r.onsuccess=()=>{this.db=r.result,e()},r.onupgradeneeded=e=>{const t=e.target.result;this.schema.forEach((e=>{var r;if(!t.objectStoreNames.contains(e.name)){const s=t.createObjectStore(e.name,{keyPath:e.keyPath,autoIncrement:e.autoIncrement});null===(r=e.indexes)||void 0===r||r.forEach((e=>{s.createIndex(e.name,e.keyPath,e.options)}))}}))}}))}table(e){return new t(this,e)}async add(e,t){const r=await this.getStore(e,"readwrite");return new Promise(((e,s)=>{const n=r.add(t);n.onsuccess=()=>e(n.result),n.onerror=()=>s(n.error)}))}async put(e,t){const r=await this.getStore(e,"readwrite");return new Promise(((e,s)=>{const n=r.put(t);n.onsuccess=()=>e(n.result),n.onerror=()=>s(n.error)}))}async get(e,t){const r=await this.getStore(e);return new Promise(((e,s)=>{const n=r.get(t);n.onsuccess=()=>e(n.result),n.onerror=()=>s(n.error)}))}async getAll(e){const t=await this.getStore(e);return new Promise(((e,r)=>{const s=t.getAll();s.onsuccess=()=>e(s.result),s.onerror=()=>r(s.error)}))}async delete(e,t){const r=await this.getStore(e,"readwrite");return new Promise(((e,s)=>{const n=r.delete(t);n.onsuccess=()=>e(),n.onerror=()=>s(n.error)}))}async findByIndex(e,t,r){const s=(await this.getStore(e)).index(t);return new Promise(((e,t)=>{const n=s.getAll(r);n.onsuccess=()=>e(n.result),n.onerror=()=>t(n.error)}))}async findByIndexRange(e,t,r={}){const s=(await this.getStore(e)).index(t);return new Promise(((e,t)=>{const n=[],o=s.openCursor(r.query,r.direction);let i=0,a=0;o.onsuccess=t=>{const s=t.target.result;if(s){if(r.offset&&a<r.offset)return a++,void s.continue();if(r.limit&&i>=r.limit)return void e(n);n.push(s.value),i++,s.continue()}else e(n)},o.onerror=()=>t(o.error)}))}async countByIndex(e,t,r){const s=(await this.getStore(e)).index(t);return new Promise(((e,t)=>{const n=s.count(r);n.onsuccess=()=>e(n.result),n.onerror=()=>t(n.error)}))}async count(e){const t=await this.getStore(e);return new Promise(((e,r)=>{const s=t.count();s.onsuccess=()=>e(s.result),s.onerror=()=>r(s.error)}))}async clear(e){const t=await this.getStore(e,"readwrite");return new Promise(((e,r)=>{const s=t.clear();s.onsuccess=()=>e(),s.onerror=()=>r(s.error)}))}close(){this.db&&(this.db.close(),this.db=null)}},Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.js.map
